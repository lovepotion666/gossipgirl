<!DOCTYPE html><html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Tip Thread | V1.0 OFFICIAL</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no" />
    <!-- Firebase SDKs are now loaded dynamically in script to avoid blocking first paint -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script><link href="https://fonts.googleapis.com/css2?family=Bodoni+Moda:ital,opsz,wght@0,6..96,400..900;1,6..96,400..900&display=swap" rel="stylesheet">

<style>
    :root {
        --gold-primary: #D4AF37;
        --gold-light: #F2D06B;
        --pink-neon: #FF007F;
        --blue-electric: #007AFF;

        --glass-surface: rgba(20, 20, 20, 0.75);
        --glass-border: rgba(255, 255, 255, 0.12);
        --glass-highlight: rgba(255, 255, 255, 0.18);
        --glass-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.9);

        --liquid-gold: linear-gradient(135deg, #BF953F 0%, #FCF6BA 40%, #AA771C 100%);
        --liquid-dark: linear-gradient(180deg, #1a1a1a 0%, #000000 100%);

        --ease-spring: cubic-bezier(0.175, 0.885, 0.32, 1.15);
        --ease-silk: cubic-bezier(0.25, 0.1, 0.25, 1);
    }

    /* Fixed BiDi Support */
    .gg-rtl {
        direction: rtl !important;
        text-align: right !important;
        unicode-bidi: isolate !important;
    }

    .gg-auto {
        unicode-bidi: plaintext !important;
        text-align: start !important;
        direction: auto !important;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro", "SF Arabic", "Segoe UI", Roboto, sans-serif; letter-spacing: -0.015em; }

    @media (prefers-reduced-motion: reduce) {
        * { transition: none !important; animation: none !important; scroll-behavior: auto !important; }
    }

    @keyframes liquidReveal { 0% { opacity: 0; transform: translateY(30px) scale(0.96); filter: blur(10px); } 100% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0); } }

    body {
        background: #000; color: #fff; margin: 0;
        background-image:
            radial-gradient(circle at 50% 0%, rgba(212, 175, 55, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 10% 90%, rgba(255, 0, 127, 0.08) 0%, transparent 40%),
            linear-gradient(to bottom, #050505, #000000);
        background-attachment: fixed;
        overflow-x: hidden; -webkit-font-smoothing: antialiased;
        padding-bottom: calc(140px + env(safe-area-inset-bottom));
    }

    .content-wrapper { animation: liquidReveal 0.8s var(--ease-silk) forwards; }

    .liquid-card {
        background: var(--glass-surface); backdrop-filter: blur(45px) saturate(180%);
        -webkit-backdrop-filter: blur(45px) saturate(180%); border: 1px solid var(--glass-border);
        border-top: 1px solid var(--glass-highlight); border-radius: 28px; box-shadow: var(--glass-shadow);
        transition: transform 0.4s var(--ease-spring); transform: translateZ(0); position: relative;
    }

    header {
        position: fixed; top: 0; width: 100%; z-index: 1000; padding: 15px 20px;
        display: flex; justify-content: space-between; align-items: center;
        background: rgba(0,0,0,0.7); backdrop-filter: blur(25px);
        border-bottom: 1px solid rgba(255,255,255,0.05); transform: translateZ(0);
    }

    .container { max-width: 480px; margin: 0 auto; padding: 80px 20px 20px; width: 100%; }

    .badge { display:inline-flex; align-items:center; padding:4px 10px; border-radius:10px; font-size:9px; font-weight:700; text-transform:uppercase; margin-right:6px; margin-bottom:8px; border:1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px); white-space:nowrap; letter-spacing:0.5px; }
    .b-gg { background:var(--liquid-gold); color:#000; box-shadow: 0 0 20px rgba(212,175,55,0.3); border:none; font-weight:800; }
    .b-new { background:#fff; color:#000; border:none; font-weight:800; }
    .b-verify { background:rgba(255,255,255,0.08); color:#fff; }
    .b-hot { background: rgba(255, 0, 127, 0.15); color:var(--pink-neon); border-color:var(--pink-neon); box-shadow:0 0 15px rgba(255,0,127,0.25); }

    .v-indicator { background:var(--blue-electric); color:white; min-width:16px; height:16px; border-radius:50%; font-size:9px; display:inline-flex; align-items:center; justify-content:center; margin-left:6px; box-shadow:0 0 10px rgba(0,122,255,0.6); font-weight:800; padding:0 4px; }

    .input-wrapper { position: fixed; bottom: calc(20px + env(safe-area-inset-bottom)); left: 50%; transform: translateX(-50%) translateZ(0); width: 92%; max-width: 450px; z-index: 9999; }

    .input-bar { display:flex; align-items:center; gap:12px; padding:8px 10px 8px 20px; border-radius:40px; background: rgba(20,20,20,0.9) !important; backdrop-filter: blur(40px) saturate(200%); box-shadow: 0 10px 40px rgba(0,0,0,0.8), inset 0 1px 1px rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.15); }

    #ci { flex:1; background:transparent; border:none; color:#fff; font-size:16px; padding:12px 0; outline:none; font-weight:400; }
    #ci::placeholder { color: rgba(255,255,255,0.3); }

    .action-btn { width:44px; height:44px; border-radius:50%; border:none; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:0.3s cubic-bezier(0.175,0.885,0.32,1.275); }
    .action-btn:active { transform: scale(0.8); }
    .btn-send { background:var(--liquid-gold); color:#000; font-weight:700; font-size:18px; box-shadow: 0 5px 15px rgba(212,175,55,0.3); }

    .verify-btn, .share-btn { flex:1; height:40px; border-radius:14px; font-size:10px; font-weight:800; text-transform:uppercase; letter-spacing:0.8px; cursor:pointer; transition:0.3s; display:flex; align-items:center; justify-content:center; }
    .verify-btn { background: rgba(0,122,255,0.15); color:#4DAFFF; border:1px solid rgba(0,122,255,0.3); }
    .verify-btn.active { background: var(--blue-electric); color: white; border-color: transparent; box-shadow: 0 0 20px rgba(0,122,255,0.5); }
    
    .verify-btn.admin-verify { background: var(--liquid-gold); color: #000; border: none; box-shadow: 0 0 20px rgba(212,175,55,0.4); }

    .share-btn { background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border); color:#fff; }

    .post-img-preview { width:100%; aspect-ratio:4/3; object-fit:cover; border-radius:20px; margin-bottom:25px; border:1px solid rgba(255,255,255,0.1); display:block; box-shadow:0 10px 30px rgba(0,0,0,0.5); cursor: zoom-in; }

    #lightbox { position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:10001; display:none; align-items:center; justify-content:center; backdrop-filter: blur(10px); }
    #lightbox img { max-width:95%; max-height:90%; border-radius:12px; }

    .comment-swipe-zone { position:relative; touch-action: pan-y; margin-bottom:10px; transform: translateZ(0); }

    #ggToast { position: fixed; top: 80px; left: 50%; transform: translateX(-50%); background: var(--liquid-gold); color: #000; padding: 12px 24px; border-radius: 20px; font-weight: 800; font-size: 11px; z-index: 10000; display: none; box-shadow: 0 10px 30px rgba(0,0,0,0.5); letter-spacing: 1px; text-align: center; white-space: nowrap; }
    .empty-state { text-align:center; padding:40px 20px; color: rgba(255,255,255,0.3); font-weight:600; font-size:14px; letter-spacing:0.5px; }

    .main-card { will-change: transform; }
</style>

</head>
<body><div id="ggToast" role="status" aria-live="polite">VERIFIED BY GOSSIP GIRL</div><div id="lightbox" role="dialog" aria-modal="true" aria-hidden="true">
    <img src="" id="lightboxImg" alt="Full image">
</div><div class="content-wrapper">
    <header>
        <a href="index.html" style="color:var(--gold-primary); text-decoration:none; font-weight:700; font-size:11px; letter-spacing:1px; display:flex; align-items:center; gap:4px;" aria-label="Back to home">
            <span style="font-size:14px;">â€¹</span> BACK
        </a>
        <div style="font-family:'Bodoni Moda', serif; font-style:italic; font-weight:800; letter-spacing:0.5px; font-size:18px; background:var(--liquid-gold); -webkit-background-clip:text; -webkit-text-fill-color:transparent;">Tip Thread</div>
        <div style="width:40px;"></div>
    </header><main class="container" id="mainContainer">
    <div id="postArea" aria-live="polite"></div>

    <div style="margin:35px 0 15px 8px; display:flex; align-items:baseline; gap:10px;">
        <span style="font-weight:800; font-size:24px; letter-spacing:-0.5px; color:#fff;">Comments</span>
        <span id="commentCount" style="font-weight:700; font-size:16px; color:var(--gold-primary); opacity:0.8;">0</span>
    </div>

    <div id="cFeed" aria-live="polite"></div>
</main>

</div><div class="input-wrapper" aria-label="Add a comment">
    <div id="replyBanner" style="display:none; pointer-events:auto; background: rgba(212,175,55,0.15); backdrop-filter: blur(20px); border-radius: 25px 25px 0 0; padding:10px 24px; font-size:10px; font-weight:800; justify-content:space-between; align-items:center; color:var(--gold-primary); border:1px solid rgba(212,175,55,0.3); border-bottom:none; margin:0 20px;">
        <span>REPLYING...</span>
        <span id="replyCancel" role="button" tabindex="0" style="cursor:pointer; background:rgba(0,0,0,0.4); color:#fff; padding:4px 10px; border-radius:12px; font-size:9px;">CANCEL</span>
    </div><div class="liquid-card input-bar" role="form" aria-label="Comment form">
    <input type="text" id="ci" placeholder="Start controversy..." autocomplete="off" aria-label="Comment input">
    <button class="action-btn btn-send" id="cb" aria-label="Send comment">â†‘</button>
</div>

</div><script>
(function(){
    'use strict';

    /* ---------- Utilities ---------- */
    function escapeHTML(s) {
        if (s === null || s === undefined) return '';
        return String(s)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;')
            .replace(/\//g, '&#x2F;');
    }
    function sanitizeForId(str) {
        if (!str) return 'id_unknown';
        return String(str).replace(/[^a-zA-Z0-9-_:.]/g, '_');
    }
    function safeNumber(n){ const v = Number(n); return isNaN(v)?0:v; }
    function timeAgo(t) {
        if(!t) return 'now';
        const s = Math.floor((Date.now() - Number(t)) / 1000);
        if(s < 30) return 'Just now';
        if(s < 3600) return Math.floor(s/60) + 'm ago';
        if(s < 86400) return Math.floor(s/3600) + 'h ago';
        return Math.floor(s/86400) + 'd ago';
    }

    // Important: non-global regex to avoid stateful test issues
    const arabicRegex = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;

    function applyAutoDirToElement(el){
        if(!el) return;
        const txt = (el.textContent || el.innerText || '').trim();
        if(!txt) return;

        const hasArabic = arabicRegex.test(txt);

        // Ensure classes & attrs are predictable
        el.removeAttribute('dir');
        el.classList.remove('gg-rtl', 'gg-auto');

        if (hasArabic) {
            // use dir=auto + isolated bidi behavior to keep mixed content sane
            el.style.unicodeBidi = 'plaintext';
            el.style.textAlign = 'start';
            el.dir = 'auto';
            el.classList.add('gg-auto');
        } else {
            el.dir = 'ltr';
            el.style.unicodeBidi = 'normal';
        }
    }

    /* Limit mutation observer work: only target nodes likely to contain text needing bidi handling */
    const mutationObserver = new MutationObserver(mutations => {
        try {
            for (const m of mutations) {
                if (!m.addedNodes) continue;
                for (const node of m.addedNodes) {
                    if (!node || node.nodeType !== 1) continue;
                    // Only process if node is a likely content node
                    if (node.classList && (node.classList.contains('post-text-content') || node.classList.contains('liquid-card') || node.classList.contains('main-card') || node.classList.contains('comment-swipe-zone'))) {
                        applyAutoDirToElement(node);
                        continue;
                    }
                    // Also check for any direct child content nodes inside
                    const inner = node.querySelector && node.querySelector('.post-text-content, .liquid-card, .main-card, .comment-swipe-zone');
                    if (inner) applyAutoDirToElement(inner);
                }
            }
        } catch(e){ /* don't let observer crash app */ }
    });
    mutationObserver.observe(document.body, { childList: true, subtree: true });

    /* ---------- Firebase Setup (deferred) ---------- */
    const firebaseConfig = {
        apiKey: "AIzaSyCTdVcJspQxXiq_Kd7ImL32xWsjv0HgENE",
        authDomain: "gossip-girl-4c9f2.firebaseapp.com",
        projectId: "gossip-girl-4c9f2",
        databaseURL: "https://gossip-girl-4c9f2-default-rtdb.firebaseio.com"
    };

    let db = null;
    // helper: load SDKs dynamically if needed, non-blocking
    function ensureFirebaseSDKs(cb) {
        if (typeof firebase !== 'undefined' && firebase && firebase.database) {
            try { if (!firebase.apps || !firebase.apps.length) firebase.initializeApp(firebaseConfig); } catch(e){}
            try { db = firebase.database(); } catch(e){}
            if (cb) cb();
            return;
        }
        const urls = [
            'https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js',
            'https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js'
        ];
        let loaded = 0;
        function onFinish() {
            try {
                if (!firebase.apps || !firebase.apps.length) firebase.initializeApp(firebaseConfig);
            } catch(e){}
            try { db = firebase.database(); } catch(e){ db = null; }
            if (cb) cb();
        }
        urls.forEach(u => {
            const s = document.createElement('script');
            s.src = u;
            s.async = true;
            s.onload = () => { loaded++; if (loaded === urls.length) onFinish(); };
            s.onerror = () => { loaded++; if (loaded === urls.length) onFinish(); };
            document.head.appendChild(s);
        });
    }

    // run after paint to avoid blocking
    function runWhenIdle(fn) {
        if ('requestIdleCallback' in window) requestIdleCallback(fn, {timeout: 1200});
        else setTimeout(fn, 500);
    }

    /* ---------- Page state & DOM refs ---------- */
    const pid = new URLSearchParams(window.location.search).get('id');
    const myUid = localStorage.getItem('gg_id') || 'anon';
    const IS_GG = sessionStorage.getItem('admin_auth') === 'true';

    const postArea = document.getElementById('postArea');
    const cFeed = document.getElementById('cFeed');
    const commentCountEl = document.getElementById('commentCount');
    const ci = document.getElementById('ci');
    const cb = document.getElementById('cb');
    const replyBanner = document.getElementById('replyBanner');
    const replyCancel = document.getElementById('replyCancel');
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightboxImg');
    const ggToast = document.getElementById('ggToast');

    if (!pid) {
        // keep behavior: redirect to index if no pid
        setTimeout(() => { window.location.href = 'index.html'; }, 300);
        return;
    }

    try {
        if (ci) {
            ci.style.unicodeBidi = 'plaintext';
            ci.setAttribute('dir', 'auto');
        }
    } catch (e){}

    let replyToId = null;
    let isSubmitting = false;

    function createTextNodeHTML(text) {
        return escapeHTML(text || '');
    }

    /* ---------- Rendering main post ---------- */
    function renderMainPost(p) {
        if (!postArea) return;
        p = p || {};
        const vCount = safeNumber(p.verifyCount || 0);
        const views = safeNumber(p.views || 0);
        const date = p.date || 0;
        const badges = [];
        if (p.verifiedByGG) badges.push('<span class="badge b-gg">Verified by Gossip Girl</span>');
        if ((Date.now() - date) < 43200000) badges.push('<span class="badge b-new">New</span>');
        if (vCount >= 100) badges.push('<span class="badge b-new" style="background:#fff;color:#000;">Confirmed</span>');

        postArea.innerHTML = '';
        const outer = document.createElement('div');
        outer.className = 'liquid-card post-box';
        outer.style.padding = '24px';
        outer.style.borderRadius = '28px';
        outer.style.position = 'relative';

        const reads = document.createElement('div');
        reads.style.position = 'absolute';
        reads.style.top = '24px';
        reads.style.right = '24px';
        reads.style.fontSize = '10px';
        reads.style.color = 'var(--gold-primary)';
        reads.style.fontWeight = '700';
        reads.style.opacity = '0.8';
        reads.textContent = 'ðŸ‘ ' + views + ' READS';
        outer.appendChild(reads);

        if (badges.length) {
            const bWrap = document.createElement('div');
            bWrap.style.marginBottom = '14px';
            bWrap.style.display = 'flex';
            bWrap.style.flexWrap = 'wrap';
            bWrap.style.maxWidth = '75%';
            bWrap.innerHTML = badges.join('');
            outer.appendChild(bWrap);
        }

        const headerRow = document.createElement('div');
        headerRow.style.display = 'flex';
        headerRow.style.gap = '12px';
        headerRow.style.alignItems = 'center';
        headerRow.style.marginBottom = '20px';

        const avatar = document.createElement('div');
        avatar.style.width = '38px';
        avatar.style.height = '38px';
        avatar.style.background = 'rgba(255,255,255,0.05)';
        avatar.style.borderRadius = '50%';
        avatar.style.display = 'flex';
        avatar.style.alignItems = 'center';
        avatar.style.justifyContent = 'center';
        avatar.style.fontSize = '18px';
        avatar.style.border = '1px solid rgba(255,255,255,0.1)';
        avatar.style.color = 'var(--gold-primary)';
        avatar.style.fontFamily = "'Bodoni Moda'";
        avatar.style.fontStyle = 'italic';
        avatar.textContent = '?';
        headerRow.appendChild(avatar);

        const headerMeta = document.createElement('div');
        headerMeta.style.flex = '1';
        const nameRow = document.createElement('div');
        nameRow.style.display = 'flex';
        nameRow.style.alignItems = 'center';
        const anon = document.createElement('div');
        anon.style.fontWeight = '700';
        anon.style.fontSize = '14px';
        anon.style.color = '#fff';
        anon.textContent = 'Anonymous';
        nameRow.appendChild(anon);

        if (vCount > 0) {
            const vInd = document.createElement('div');
            vInd.className = 'v-indicator';
            vInd.textContent = String(vCount);
            vInd.style.marginLeft = '8px';
            nameRow.appendChild(vInd);
        }

        headerMeta.appendChild(nameRow);
        const timeEl = document.createElement('div');
        timeEl.style.fontSize = '10px';
        timeEl.style.opacity = '0.5';
        timeEl.style.fontWeight = '600';
        timeEl.textContent = timeAgo(date);
        headerMeta.appendChild(timeEl);
        headerRow.appendChild(headerMeta);
        outer.appendChild(headerRow);

        const textDiv = document.createElement('div');
        textDiv.className = 'post-text-content';
        textDiv.style.fontSize = '16px';
        textDiv.style.lineHeight = '1.5';
        textDiv.style.marginBottom = '20px';
        textDiv.style.color = 'rgba(255,255,255,0.92)';
        textDiv.style.fontWeight = '400';
        textDiv.style.letterSpacing = '0.1px';
        textDiv.innerHTML = createTextNodeHTML(p.text);
        outer.appendChild(textDiv);

        try { applyAutoDirToElement(textDiv); } catch(e){}

        if (p.image) {
            const img = document.createElement('img');
            img.className = 'post-img-preview';
            img.alt = 'post image';
            try { img.src = p.image; } catch(e){ img.src = ''; }
            img.loading = 'lazy';
            img.addEventListener('click', () => openLightbox(p.image));
            // ensure crossOrigin where possible to help html2canvas
            try { img.crossOrigin = 'anonymous'; } catch(e){}
            outer.appendChild(img);
        }

        const actionRow = document.createElement('div');
        actionRow.id = 'actionRow';
        actionRow.style.display = 'flex';
        actionRow.style.gap = '12px';
        actionRow.style.justifyContent = 'space-between';
        actionRow.style.alignItems = 'center';
        actionRow.style.borderTop = '1px solid rgba(255,255,255,0.08)';
        actionRow.style.paddingTop = '16px';

        const vBtn = document.createElement('button');
        vBtn.id = 'vBtn';
        vBtn.className = 'verify-btn';
        vBtn.textContent = 'VERIFY';
        
        if (IS_GG) {
            vBtn.classList.add('admin-verify');
        } else if (p.verifiedByGG || (p.verifiers && p.verifiers[myUid])) {
            vBtn.classList.add('active');
        }
        actionRow.appendChild(vBtn);

        const sBtn = document.createElement('button');
        sBtn.id = 'sBtn';
        sBtn.className = 'share-btn';
        sBtn.textContent = 'SHARE';
        actionRow.appendChild(sBtn);

        outer.appendChild(actionRow);
        postArea.appendChild(outer);

        vBtn.addEventListener('click', () => toggleVerify(pid, vBtn));
        sBtn.addEventListener('click', () => shareTip());
    }

    /* ---------- Lightbox ---------- */
    function openLightbox(url) {
        try {
            if (!lightbox || !lightboxImg) return;
            lightboxImg.src = url || '';
            lightbox.style.display = 'flex';
            lightbox.setAttribute('aria-hidden', 'false');
            setTimeout(() => window.addEventListener('keydown', lightboxEsc), 0);
        } catch(e){}
    }
    function closeLightbox() {
        if (!lightbox || !lightboxImg) return;
        lightbox.style.display = 'none';
        lightboxImg.src = '';
        lightbox.setAttribute('aria-hidden', 'true');
        window.removeEventListener('keydown', lightboxEsc);
    }
    function lightboxEsc(e){ if(e.key === 'Escape') closeLightbox(); }

    if (lightbox) {
        lightbox.addEventListener('click', (ev) => {
            if (ev.target === lightbox) closeLightbox();
        });
    }

    /* ---------- Verify logic (transactional) ---------- */
    function toggleVerify(pidLocal, btnEl) {
        if (!db) return;
        const ref = db.ref('posts/' + pidLocal);
        ref.transaction(p => {
            if (!p) return p;
            if (IS_GG) {
                p.verifiedByGG = true;
            } else {
                p.verifiers = p.verifiers || {};
                if (p.verifiers[myUid]) {
                    delete p.verifiers[myUid];
                    p.verifyCount = Math.max(0, safeNumber(p.verifyCount) - 1);
                } else {
                    p.verifiers[myUid] = true;
                    p.verifyCount = safeNumber(p.verifyCount) + 1;
                }
            }
            return p;
        }, (error, committed, snapshot) => {
            if (error) return;
            if (committed && IS_GG) {
                if (ggToast) {
                    ggToast.style.display = 'block';
                    setTimeout(() => ggToast.style.display = 'none', 3000);
                }
            }
            try {
                const newP = snapshot && snapshot.val() ? snapshot.val() : null;
                if (newP && btnEl) {
                    if (IS_GG) {
                        btnEl.classList.add('admin-verify');
                    } else {
                        const has = (newP.verifiedByGG || (newP.verifiers && newP.verifiers[myUid]));
                        btnEl.classList.toggle('active', Boolean(has));
                    }
                }
            } catch(e){}
        });
    }

    /* ---------- Render and setup comments ---------- */
    function renderComments(data) {
        if (!cFeed || !commentCountEl) return;
        data = data || {};
        const keys = Object.keys(data || {});
        if (keys.length === 0) {
            cFeed.innerHTML = '<div class="empty-state">What do you have in mind?</div>';
            commentCountEl.textContent = '0';
            return;
        }

        const main = [];
        const replies = {};
        keys.forEach(k => {
            const c = data[k];
            if (!c) return;
            c.id = k;
            if (c.replyTo) {
                replies[c.replyTo] = replies[c.replyTo] || [];
                replies[c.replyTo].push(c);
            } else main.push(c);
        });

        commentCountEl.textContent = String(keys.length);
        cFeed.innerHTML = '';

        main.sort((a,b) => (safeNumber(b.date) - safeNumber(a.date))).forEach((c, idx) => {
            const wrap = document.createElement('div');
            wrap.className = 'comment-swipe-zone';
            wrap.id = 'wrap-' + sanitizeForId(c.id);
            wrap.style.animation = 'liquidReveal 0.6s cubic-bezier(0.2,0.8,0.2,1) forwards';
            wrap.style.animationDelay = (idx * 0.05) + 's';
            wrap.style.opacity = '0';
            wrap.style.transform = 'translateY(20px)';

            const card = document.createElement('div');
            card.className = 'liquid-card main-card';
            card.style.padding = '18px';
            card.style.position = 'relative';
            card.style.zIndex = '2';
            card.style.transition = 'background 0.2s';

            const headerRow = document.createElement('div');
            headerRow.style.display = 'flex';
            headerRow.style.gap = '10px';
            headerRow.style.marginBottom = '8px';
            headerRow.style.alignItems = 'center';

            const avatar = document.createElement('div');
            avatar.style.width = '28px';
            avatar.style.height = '28px';
            avatar.style.background = 'linear-gradient(135deg, #222, #111)';
            avatar.style.borderRadius = '50%';
            avatar.style.display = 'flex';
            avatar.style.alignItems = 'center';
            avatar.style.justifyContent = 'center';
            avatar.style.fontSize = '12px';
            avatar.style.border = '1px solid rgba(255,255,255,0.1)';
            avatar.style.color = 'var(--gold-primary)';
            avatar.style.fontFamily = "'Bodoni Moda'";
            avatar.style.fontStyle = 'italic';
            avatar.textContent = '?';
            headerRow.appendChild(avatar);

            const meta = document.createElement('div');
            meta.style.flex = '1';
            const name = document.createElement('div');
            name.style.fontWeight = '700';
            name.style.fontSize = '12px';
            name.style.color = '#fff';
            name.textContent = 'Anonymous';
            meta.appendChild(name);
            const t = document.createElement('div');
            t.style.fontSize = '9px';
            t.style.opacity = '0.4';
            t.style.fontWeight = '600';
            t.textContent = timeAgo(c.date);
            meta.appendChild(t);
            headerRow.appendChild(meta);
            card.appendChild(headerRow);

            const txt = document.createElement('div');
            txt.style.fontSize = '13px';
            txt.style.lineHeight = '1.4';
            txt.style.color = 'rgba(255,255,255,0.9)';
            txt.innerHTML = createTextNodeHTML(c.text);
            try { applyAutoDirToElement(txt); } catch(e){}
            card.appendChild(txt);
            wrap.appendChild(card);

            if (replies[c.id]) {
                const repliesWrap = document.createElement('div');
                repliesWrap.style.marginLeft = '20px';
                repliesWrap.style.marginTop = '8px';
                repliesWrap.style.borderLeft = '1.5px solid rgba(255,255,255,0.08)';
                repliesWrap.style.paddingLeft = '12px';
                replies[c.id].forEach(r => {
                    const rCard = document.createElement('div');
                    rCard.className = 'liquid-card';
                    rCard.style.padding = '12px';
                    rCard.style.marginBottom = '8px';
                    rCard.style.borderRadius = '18px';
                    rCard.style.background = 'rgba(255,255,255,0.02)';
                    rCard.style.border = '1px solid rgba(255,255,255,0.04)';
                    const rTag = document.createElement('div');
                    rTag.style.fontWeight = '700';
                    rTag.style.fontSize = '9px';
                    rTag.style.color = 'var(--gold-primary)';
                    rTag.style.marginBottom = '4px';
                    rTag.style.opacity = '0.8';
                    rTag.textContent = 'REPLY';
                    rCard.appendChild(rTag);
                    const rText = document.createElement('div');
                    rText.style.fontSize = '12px';
                    rText.style.opacity = '0.9';
                    rText.style.lineHeight = '1.4';
                    rText.innerHTML = createTextNodeHTML(r.text);
                    try { applyAutoDirToElement(rText); } catch(e){}
                    rCard.appendChild(rText);
                    repliesWrap.appendChild(rCard);
                });
                wrap.appendChild(repliesWrap);
            }
            cFeed.appendChild(wrap);
            setupSwipeHandler(c.id, wrap, card);
        });
    }

    /* ---------- Swipe to reply handler (robust) ---------- */
    function setupSwipeHandler(cid, row, card) {
        if(!row || !card) return;
        let startX = 0, startY = 0, isSwiping = false, isScrolling = false;
        row.addEventListener('touchstart', (e) => {
            startX = e.touches && e.touches[0] ? e.touches[0].clientX : 0;
            startY = e.touches && e.touches[0] ? e.touches[0].clientY : 0;
            isSwiping = false;
            isScrolling = false;
            card.style.transition = 'none';
        }, {passive:true});
        row.addEventListener('touchmove', (e) => {
            if (!e.touches || !e.touches[0]) return;
            const diffX = startX - e.touches[0].clientX;
            const diffY = Math.abs(startY - e.touches[0].clientY);
            if (!isSwiping && !isScrolling) {
                if (diffY > 10) isScrolling = true;
                else if (diffX > 10) isSwiping = true;
            }
            if (isSwiping && diffX > 0) {
                const move = Math.min(diffX, 80);
                requestAnimationFrame(()=> { card.style.transform = `translateX(-${move}px)`; });
                if (diffX > 70 && replyToId !== cid) {
                    replyToId = cid;
                    if (replyBanner) replyBanner.style.display = 'flex';
                    try { if (navigator.vibrate) navigator.vibrate(10); } catch(e){}
                    card.style.background = 'rgba(255,255,255,0.08)';
                }
            }
        }, {passive:true});
        row.addEventListener('touchend', () => {
            card.style.transition = 'transform 0.4s var(--ease-spring), background 0.3s';
            requestAnimationFrame(() => { card.style.transform = 'translateX(0px)'; });
            setTimeout(()=>{ if(!replyToId || replyToId !== cid) card.style.background = ''; }, 400);
        }, {passive:true});
    }

    /* ---------- SHARE / html2canvas improvements ---------- */
    function shareTip() {
        const cap = document.querySelector('.post-box');
        if (!cap) return;

        const actionRow = document.getElementById('actionRow');
        const readsInd = cap.querySelector('div[style*="READS"]');
        const originalImg = cap.querySelector('.post-img-preview');

        if (actionRow) actionRow.style.display = 'none';
        if (readsInd) readsInd.style.display = 'none';

        // Use a lower scale to avoid memory spikes (scale 3 is a good balance)
        // Also wrap in try/catch because html2canvas may fail on some browsers / blocked resources
        try {
            html2canvas(cap, {
                backgroundColor: '#000000',
                scale: 3,
                useCORS: true,
                allowTaint: false,
                letterRendering: true,
                onclone: (clonedDoc) => {
                    try {
                        const clonedImg = clonedDoc.querySelector('.post-img-preview');
                        const clonedText = clonedDoc.querySelector('.post-text-content');

                        if (clonedImg && originalImg) {
                            const width = originalImg.offsetWidth || originalImg.clientWidth || 400;
                            const height = originalImg.offsetHeight || originalImg.clientHeight || Math.round(width * 0.75);
                            const src = originalImg.src || '';
                            const replacement = clonedDoc.createElement('div');
                            replacement.style.width = width + 'px';
                            replacement.style.height = height + 'px';
                            replacement.style.backgroundImage = src ? `url(${src})` : 'none';
                            replacement.style.backgroundSize = 'cover';
                            replacement.style.backgroundPosition = 'center';
                            replacement.style.borderRadius = '20px';
                            replacement.style.marginBottom = '25px';
                            replacement.style.border = '1px solid rgba(255,255,255,0.1)';
                            if (clonedImg.parentNode) clonedImg.parentNode.replaceChild(replacement, clonedImg);
                        }

                        if (clonedText) {
                            const rawTxt = (clonedText.textContent || clonedText.innerText || '').trim();
                            const hasArabic = arabicRegex.test(rawTxt);

                            clonedText.style.letterSpacing = '0px';
                            clonedText.style.wordSpacing = '0px';
                            clonedText.style.whiteSpace = 'pre-wrap';
                            clonedText.style.wordBreak = 'break-word';
                            clonedText.style.lineHeight = '1.6';

                            if (hasArabic) {
                                clonedText.style.direction = 'rtl';
                                clonedText.style.textAlign = 'right';
                                clonedText.style.unicodeBidi = 'isolate';
                                clonedText.setAttribute('dir', 'rtl');
                            } else {
                                clonedText.style.direction = 'ltr';
                                clonedText.style.textAlign = 'left';
                                clonedText.setAttribute('dir', 'ltr');
                            }
                        }
                    } catch(e){}
                }
            }).then(canvas => {
                try {
                    if (actionRow) actionRow.style.display = 'flex';
                    if (readsInd) readsInd.style.display = 'block';

                    canvas.toBlob(blob => {
                        if (!blob) return;
                        const file = new File([blob], 'gossip_girl.png', { type: 'image/png' });
                        if (navigator.canShare && navigator.canShare({ files: [file] })) {
                            try { navigator.share({ files: [file], title: 'Gossip Girl' }); }
                            catch(e){ downloadBlob(blob); }
                        } else {
                            downloadBlob(blob);
                        }
                    }, 'image/png', 1.0);
                } catch(e){
                    if (actionRow) actionRow.style.display = 'flex';
                    if (readsInd) readsInd.style.display = 'block';
                    // fallback: alert and re-show controls
                    console.warn('Share failed', e);
                }
            }).catch(err => {
                if (actionRow) actionRow.style.display = 'flex';
                if (readsInd) readsInd.style.display = 'block';
                console.warn('html2canvas failed', err);
            });
        } catch (ex) {
            if (actionRow) actionRow.style.display = 'flex';
            if (readsInd) readsInd.style.display = 'block';
            console.warn('shareTip unexpected', ex);
        }
    }

    function downloadBlob(blob) {
        try {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'gossip_girl.png';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                try { URL.revokeObjectURL(url); } catch(e){}
                try { a.remove(); } catch(e){}
            }, 5000);
        } catch(e){ console.warn('download fallback failed', e); }
    }

    /* ---------- Comment submit ---------- */
    cb && cb.addEventListener('click', () => {
        if (isSubmitting) return;
        const txt = (ci && ci.value) ? ci.value.trim() : '';
        if (!txt || !db) return;
        isSubmitting = true;

        // prefer server timestamp, but fallback to Date.now() if firebase not available
        const payload = { text: txt, date: (firebase && firebase.database && firebase.database.ServerValue && firebase.database.ServerValue.TIMESTAMP) ? firebase.database.ServerValue.TIMESTAMP : Date.now(), replyTo: replyToId || null };

        db.ref('comments/' + pid).push(payload)
        .then(()=> { if (ci) ci.value = ''; cancelReply(); })
        .catch(()=>{})
        .finally(()=> { isSubmitting = false; });
    });

    ci && ci.addEventListener('keypress', (e) => { if (e.key === 'Enter') cb && cb.click(); });

    function cancelReply() {
        replyToId = null;
        if (replyBanner) replyBanner.style.display = 'none';
        document.querySelectorAll('.main-card').forEach(c => {
            c.style.background = '';
            c.style.transform = 'translateX(0px)';
        });
    }
    replyCancel && replyCancel.addEventListener('click', cancelReply);

    /* ---------- Init listeners & data wiring ---------- */
    function initListeners() {
        // If firebase not ready, defer initialization
        if (!db) {
            // try to initialize SDKs and then wire listeners
            runWhenIdle(() => ensureFirebaseSDKs(() => {
                runWhenIdle(() => {
                    try { // re-run wiring if db now available
                        if (!db && typeof firebase !== 'undefined' && firebase && firebase.database) db = firebase.database();
                    } catch(e){}
                    attachDBListeners();
                });
            }));
            return;
        }
        attachDBListeners();
    }

    function attachDBListeners() {
        if (!db) return;
        try {
            // increment views once per client (defensive)
            let viewed = [];
            try { viewed = JSON.parse(localStorage.getItem('gg_viewed_posts') || '[]'); } catch(e){}
            if (!viewed.includes(pid)) {
                try { db.ref('posts/' + pid + '/views').transaction(v => (safeNumber(v) + 1)); } catch(e){}
                viewed.push(pid);
                try { localStorage.setItem('gg_viewed_posts', JSON.stringify(viewed)); } catch(e){}
            }
        } catch(e){}

        try {
            db.ref('comments/' + pid).on('value', snap => renderComments(snap.val() || {}));
            db.ref('posts/' + pid).on('value', snap => {
                const p = snap.val();
                if (!p) { window.location.href = 'index.html'; return; }
                renderMainPost(p);
            });
        } catch(e){
            console.warn('DB listeners attach failed', e);
        }
    }

    // start initialization
    runWhenIdle(() => ensureFirebaseSDKs(() => initListeners()));

    // expose lightbox helpers if needed elsewhere
    window.openLightbox = openLightbox;
    window.closeLightbox = closeLightbox;

})();
</script><!-- ===========================
     INJECTIONS: Enhancements
     (all additions appended; original file above left intact)
     =========================== --><style id="gg-enhancements">
    /* Visual refinements for iOS 26 Liquid Glass aesthetic and SF fonts */
    @supports (backdrop-filter: blur(1px)) {
        .liquid-card { border-radius: 24px; box-shadow: 0 8px 30px rgba(0,0,0,0.6); }
    }

    /* Emoji and system font stack to prioritize iOS-style emojis where available */
    :root { --emoji-fonts: "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Twemoji Mozilla"; }
    body { font-family: -apple-system, "SF Pro Display", "SF Arabic", "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
    .liquid-card, .input-bar, .verify-btn, .share-btn, .action-btn { transition: transform 220ms var(--ease-silk), box-shadow 220ms var(--ease-silk), background 220ms var(--ease-silk); }
    .verify-btn:hover, .share-btn:hover { transform: translateY(-4px); box-shadow: 0 10px 30px rgba(0,0,0,0.5); }

    /* Stronger glass look for action row */
    #actionRow { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02)); padding: 12px; border-radius: 14px; }

    /* Lightbox zoom transforms */
    #lightbox img { transition: transform 220ms var(--ease-silk); touch-action: none; will-change: transform; }

    /* Make placeholder and empty-state more stylish */
    .empty-state { font-style: italic; color: rgba(255,255,255,0.35); }
    #ci::placeholder { font-style: italic; opacity: 0.9; letter-spacing: -0.2px; }

    /* RTL tweaks when .gg-rtl applied */
    .gg-rtl .liquid-card { direction: rtl; text-align: right; }
</style><script>
(function(){
    'use strict';

    /* ---------- Small utilities ---------- */
    function $(sel, ctx){ return (ctx || document).querySelector(sel); }
    function $all(sel, ctx){ return Array.from((ctx || document).querySelectorAll(sel)); }
    function on(el, ev, fn, opts){ if(!el) return; el.addEventListener(ev, fn, opts); }
    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
    function isElementVisible(el){ if(!el) return false; const r = el.getBoundingClientRect(); return !(r.width===0 && r.height===0); }

    /* ---------- Text replacements (no change to original source lines) ---------- */
    (function replaceStaticText(){
        try {
            // Placeholder replacement for comment input
            const ci = document.getElementById('ci');
            if (ci) ci.placeholder = 'Spill the teaâ€¦';

            // Observe cFeed to replace empty-state default
            const feed = document.getElementById('cFeed');
            if (feed) {
                const mo = new MutationObserver(muts => {
                    muts.forEach(m => {
                        m.addedNodes && m.addedNodes.forEach(node => {
                            if (node && node.nodeType === 1 && node.classList.contains('empty-state')) {
                                if (node.textContent && node.textContent.trim() === 'What do you have in mind?') {
                                    node.textContent = 'No comments hereâ€¦ yet.';
                                }
                            }
                        });
                    });
                });
                mo.observe(feed, { childList: true, subtree: true });
                // Also replace existing
                $all('.empty-state').forEach(el => {
                    if (el.textContent && el.textContent.trim() === 'What do you have in mind?') el.textContent = 'No comments hereâ€¦ yet.';
                });
            }
        } catch(e){ console.warn('replaceStaticText failed', e); }
    })();

    /* ---------- Lightbox: close anywhere + pinch-to-zoom + double-tap ---------- */
    (function enhanceLightbox(){
        const lightbox = document.getElementById('lightbox');
        const img = document.getElementById('lightboxImg');
        if (!lightbox || !img) return;

        let isPinching = false;
        let startDist = 0;
        let baseScale = 1;
        let currentScale = 1;
        let lastTap = 0;
        let pos = { x:0, y:0 }, lastPos = { x:0, y:0 }, isDragging=false;

        function getDist(touches){
            const a = touches[0], b = touches[1];
            const dx = a.clientX - b.clientX, dy = a.clientY - b.clientY;
            return Math.hypot(dx, dy);
        }
        function setTransform(scale, tx=0, ty=0){
            img.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
        }

        // Pointer / touch handlers
        img.addEventListener('touchstart', (ev) => {
            if (!ev.touches) return;
            if (ev.touches.length === 2) {
                isPinching = true;
                startDist = getDist(ev.touches);
                baseScale = currentScale || 1;
            } else if (ev.touches.length === 1) {
                isDragging = true;
                lastPos.x = ev.touches[0].clientX;
                lastPos.y = ev.touches[0].clientY;
            }
        }, {passive:true});

        img.addEventListener('touchmove', (ev) => {
            if (isPinching && ev.touches && ev.touches.length === 2) {
                const d = getDist(ev.touches);
                const scale = Math.max(1, Math.min(4, baseScale * (d / startDist)));
                currentScale = scale;
                setTransform(currentScale, pos.x, pos.y);
            } else if (isDragging && ev.touches && ev.touches.length === 1 && currentScale > 1) {
                const dx = ev.touches[0].clientX - lastPos.x;
                const dy = ev.touches[0].clientY - lastPos.y;
                pos.x += dx; pos.y += dy;
                lastPos.x = ev.touches[0].clientX; lastPos.y = ev.touches[0].clientY;
                setTransform(currentScale, pos.x, pos.y);
            }
        }, {passive:true});

        img.addEventListener('touchend', (ev) => {
            if (isPinching && (!ev.touches || ev.touches.length < 2)) isPinching = false;
            if (isDragging && (!ev.touches || ev.touches.length === 0)) isDragging = false;
            // if scale reduced to approx 1, reset position
            if (currentScale <= 1.03) {
                currentScale = 1; pos = {x:0,y:0}; setTransform(1,0,0);
            }
        }, {passive:true});

        // Double-tap to toggle zoom
        img.addEventListener('click', (ev) => {
            const now = Date.now();
            if (now - lastTap < 280) {
                // double tap
                if (currentScale <= 1.05) {
                    currentScale = 2.6;
                } else {
                    currentScale = 1;
                    pos = {x:0,y:0};
                }
                setTransform(currentScale, pos.x, pos.y);
                lastTap = 0;
            } else {
                lastTap = now;
                // single tap should close (per request: clicking anywhere closes)
                // but avoid closing if user is in the middle of pinch/drag (isPinching/isDragging)
                setTimeout(() => {
                    if (!isPinching && !isDragging) {
                        // close on single tap
                        try { window.closeLightbox && window.closeLightbox(); } catch(e){}
                    }
                }, 300);
            }
        });

        // Also allow tapping anywhere on the screen to close (outside or on image)
        // If pinch/drag is happening, we avoid accidental closes by checking flags
        const globalClose = (ev) => {
            if (isPinching || isDragging) return;
            // close
            window.closeLightbox && window.closeLightbox();
        };
        lightbox.addEventListener('click', globalClose);

        // Prevent click propagation while interacting with image to avoid immediate close on some devices
        img.addEventListener('mousedown', (ev) => { ev.stopPropagation && ev.stopPropagation(); }, {passive:true});
        img.addEventListener('touchstart', (ev) => { ev.stopPropagation && ev.stopPropagation(); }, {passive:true});

        // Reset transform on close
        const observer = new MutationObserver(muts => {
            muts.forEach(m => {
                m.removedNodes && m.removedNodes.forEach(n => {});
                m.target && m.target.getAttribute && (m.target.getAttribute('aria-hidden') === 'true') && (setTimeout(()=>{ currentScale=1; pos={x:0,y:0}; setTransform(1,0,0); }, 220));
            });
        });
        observer.observe(lightbox, { attributes: true, attributeFilter: ['aria-hidden'] });
    })();

    /* ---------- Intercept file uploads and compress images before upload ---------- */
    (function imageCompressionInterceptor(){
        // Utility to compress image file to JPEG/WEBP via canvas. Returns Promise<Blob>
        function compressFile(file, opts = {}) {
            const quality = typeof opts.quality === 'number' ? opts.quality : 0.72;
            const maxWidth = opts.maxWidth || 1600;
            const maxHeight = opts.maxHeight || 1600;
            return new Promise((resolve, reject) => {
                if (!file || !file.type || !file.type.startsWith('image/')) return reject(new Error('not-image'));
                const img = new Image();
                img.onload = () => {
                    try {
                        let w = img.width, h = img.height;
                        const ratio = Math.min(1, Math.min(maxWidth / w, maxHeight / h));
                        w = Math.round(w * ratio);
                        h = Math.round(h * ratio);
                        const canvas = document.createElement('canvas');
                        canvas.width = w;
                        canvas.height = h;
                        const ctx = canvas.getContext('2d');
                        // fill with transparent for PNG/WEBP
                        ctx.drawImage(img, 0, 0, w, h);
                        // choose output type: preserve if PNG with transparency else JPEG or WEBP
                        const outType = 'image/jpeg';
                        canvas.toBlob(blob => {
                            if (!blob) return reject(new Error('compress-failed'));
                            resolve(blob);
                        }, outType, quality);
                    } catch (e) { reject(e); }
                };
                img.onerror = (e) => reject(e);
                // Read file into dataURL
                const fr = new FileReader();
                fr.onload = () => { img.src = fr.result; };
                fr.onerror = (e) => reject(e);
                fr.readAsDataURL(file);
            });
        }

        // Replace input.files by compressing images and creating new FileList via DataTransfer
        function handleFileInputChange(evt){
            const input = evt.target;
            if (!input || input.tagName !== 'INPUT' || input.type !== 'file') return;
            const files = Array.from(input.files || []);
            if (files.length === 0) return;
            const imageFiles = files.filter(f => f.type && f.type.startsWith('image/'));
            if (imageFiles.length === 0) return;
            Promise.all(imageFiles.map(f => compressFile(f).then(b => new File([b], f.name.replace(/\.\w+$/, '.jpg'), { type: b.type || 'image/jpeg' } ) ).catch(()=>f)))
            .then(newFiles => {
                try {
                    const dt = new DataTransfer();
                    newFiles.forEach(f => dt.items.add(f));
                    // If there were non-image files, add those as-is
                    files.filter(f => !(f.type && f.type.startsWith('image/'))).forEach(f => dt.items.add(f));
                    input.files = dt.files;
                } catch(e){ console.warn('file replace failed', e); }
            }).catch(e => console.warn('compress failed', e));
        }

        // Global delegation
        document.addEventListener('change', (e) => {
            try { handleFileInputChange(e); } catch(err){}
        }, true);

        // For drag/drop uploads, add a passive compress on drop
        document.addEventListener('drop', (e) => {
            // If a file input exists in drop zone handlers elsewhere, we let those handle it
            // but as a backup, we prevent default and attempt to compress then dispatch a custom event
            // (This is intentionally lightweight; integration with specific upload code is best done server-side)
        }, false);
    })();

    /* ---------- Share feature enhancement (high-quality screenshot + crop + include link) ---------- */
    (function enhancedShareHandler(){
        // Wait until DOM element with id 'postArea' exists and then observe for buttons with id sBtn
        function attachToShareButton(btn){
            if (!btn) return;
            // Avoid attaching twice
            if (btn.__gg_enhanced) return;
            btn.__gg_enhanced = true;
            btn.addEventListener('click', async (ev) => {
                try {
                    ev.stopPropagation && ev.stopPropagation();
                    ev.preventDefault && ev.preventDefault();

                    const cap = document.querySelector('.post-box');
                    if (!cap) return;

                    const actionRow = document.getElementById('actionRow');
                    const readsInd = cap.querySelector('div[style*="READS"]');

                    // Hide UI elements we don't want in screenshot
                    if (actionRow) actionRow.style.visibility = 'hidden';
                    if (readsInd) readsInd.style.visibility = 'hidden';

                    // small delay to let styles apply
                    await new Promise(r=>setTimeout(r, 120));

                    // render high-res canvas
                    const scale = 3;
                    const canvas = await html2canvas(cap, { backgroundColor: '#000', scale: scale, useCORS:true, allowTaint:false, letterRendering:true });
                    // Crop bottom to remove action row spacing if present
                    let cropH = canvas.height;
                    if (actionRow) {
                        // compute actionRow height in pixels and convert by scale
                        const arRect = actionRow.getBoundingClientRect();
                        const capRect = cap.getBoundingClientRect();
                        const overlap = Math.max(0, (arRect.bottom - arRect.top));
                        // compute height of cap without actionRow
                        const actionRowHeightScaled = Math.round(overlap * scale);
                        cropH = Math.max(1, canvas.height - actionRowHeightScaled - Math.round(8 * scale));
                    }

                    // create cropped canvas
                    const cropped = document.createElement('canvas');
                    cropped.width = canvas.width;
                    cropped.height = cropH;
                    const ctx = cropped.getContext('2d');
                    ctx.drawImage(canvas, 0, 0, canvas.width, cropH, 0, 0, canvas.width, cropH);

                    // Convert to blob
                    const blob = await new Promise((res) => cropped.toBlob(res, 'image/png', 1.0));
                    if (!blob) throw new Error('capture-failed');

                    // Build file
                    const file = new File([blob], 'gossip_tip.png', { type: 'image/png' });

                    // Compose share data
                    const shareData = {
                        files: (navigator.canShare && navigator.canShare({ files: [file] })) ? [file] : undefined,
                        title: 'Gossip Girl tip',
                        text: 'Check out this tip on Gossip Girl',
                        url: window.location.href
                    };

                    // Use Web Share v2 if supported (files + url)
                    if (navigator.canShare && navigator.canShare({ files: [file] })) {
                        try {
                            await navigator.share(shareData);
                        } catch (err) {
                            // fallback to open share links
                            fallbackShareDownload(blob);
                        }
                    } else {
                        // Fallback: open share links + download image automatically
                        fallbackShareDownload(blob);
                    }

                    // restore hidden elements
                    if (actionRow) actionRow.style.visibility = '';
                    if (readsInd) readsInd.style.visibility = '';

                } catch (e) {
                    console.warn('enhanced share failed', e);
                    // ensure restoration
                    const actionRow = document.getElementById('actionRow');
                    const readsInd = document.querySelector('.post-box div[style*="READS"]');
                    if (actionRow) actionRow.style.visibility = '';
                    if (readsInd) readsInd.style.visibility = '';
                }
            }, {passive:false});
        }

        function fallbackShareDownload(blob){
            try {
                // Download image
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'gossip_tip.png';
                document.body.appendChild(a);
                a.click();
                setTimeout(()=>{ try{ URL.revokeObjectURL(url); a.remove(); }catch(e){} }, 4000);

                // Open social share links in new windows with the tip URL prefilled
                const tipUrl = encodeURIComponent(window.location.href);
                // Twitter
                window.open('https://twitter.com/intent/tweet?text=' + encodeURIComponent('Spill the tea:') + '&url=' + tipUrl, '_blank', 'noopener');

                // Facebook
                window.open('https://www.facebook.com/sharer/sharer.php?u=' + tipUrl, '_blank', 'noopener');

                // WhatsApp
                window.open('https://api.whatsapp.com/send?text=' + encodeURIComponent('Check this tip: ' + window.location.href), '_blank', 'noopener');

            } catch (e) {
                console.warn('fallbackShareDownload failed', e);
            }
        }

        // Observe for creation of #sBtn buttons and attach enhanced handler
        const mo = new MutationObserver(muts => {
            muts.forEach(m => {
                m.addedNodes && m.addedNodes.forEach(node => {
                    if (!node || node.nodeType !== 1) return;
                    if (node.id === 'sBtn') attachToShareButton(node);
                    // If sBtn nested inside added node
                    const s = node.querySelector && node.querySelector('#sBtn');
                    if (s) attachToShareButton(s);
                });
            });
        });
        mo.observe(document.body, { childList:true, subtree:true });

        // Attach to existing if present
        document.addEventListener('DOMContentLoaded', ()=>{ attachToShareButton(document.getElementById('sBtn')); });
        attachToShareButton(document.getElementById('sBtn'));
    })();

    /* ---------- Gossip Girl admin propagation logic ----------
       When a user is admin (sessionStorage.admin_auth === 'true'), convert their prior verifications
       to verifiedByGG across posts. This uses Firebase (if available). ---------- */
    (function gossipGirlPropagation(){
        async function ensureFirebase() {
            // Wait briefly for firebase to be available (the page loads it lazily)
            for (let i=0;i<40;i++){
                if (window.firebase && window.firebase.database) return window.firebase.database();
                await sleep(150);
            }
            return null;
        }
        async function promoteVerifications() {
            try {
                const isAdmin = sessionStorage.getItem('admin_auth') === 'true';
                if (!isAdmin) return;
                const db = await ensureFirebase();
                if (!db) return;
                const myUid = localStorage.getItem('gg_id') || 'anon';
                // Read all posts once; find posts where verifiers[myUid] is true and not verifiedByGG
                const snap = await db.ref('posts').once('value');
                const posts = snap.val() || {};
                const updates = [];
                Object.keys(posts).forEach(pid => {
                    const p = posts[pid];
                    if (!p) return;
                    if (p.verifiedByGG) return;
                    if (p.verifiers && p.verifiers[myUid]) {
                        // set verifiedByGG true
                        updates.push(pid);
                    }
                });
                // Apply updates in parallel but with slight spacing to avoid overloading DB
                for (let i=0;i<updates.length;i++){
                    const postId = updates[i];
                    try {
                        await db.ref('posts/' + postId).update({ verifiedByGG: true });
                    } catch(e){}
                    await sleep(60);
                }
                if (updates.length > 0) {
                    // show toast
                    const ggToast = document.getElementById('ggToast');
                    if (ggToast) {
                        ggToast.textContent = 'All your verifications are now VERIFIED BY GOSSIP GIRL';
                        ggToast.style.display = 'block';
                        setTimeout(()=>{ ggToast.style.display = 'none'; }, 3500);
                    }
                }
            } catch (e) { console.warn('promoteVerifications failed', e); }
        }
        // Schedule promotion when firebase available
        (async ()=>{ await sleep(500); promoteVerifications(); })();
    })();

    /* ---------- Accessibility / BiDi improvements: detect page-level Arabic and set dir/lang ---------- */
    (function pageLevelBidi(){
        try {
            const bodyText = (document.body && document.body.innerText) ? document.body.innerText : '';
            if (arabicRegex.test(bodyText)) {
                document.documentElement.lang = 'ar';
                document.documentElement.dir = 'rtl';
                document.body.classList.add('gg-rtl');
            } else {
                // keep default
                document.documentElement.dir = 'ltr';
            }
        } catch(e){}
    })();

    /* ---------- Defensive: ensure input #ci accepts Arabic well (force dir=auto) ---------- */
    (function makeInputArabicFriendly(){
        try {
            const ci = document.getElementById('ci');
            if (ci) {
                ci.setAttribute('dir', 'auto');
                ci.setAttribute('inputmode', 'text');
                // on paste, ensure text preserved properly
                ci.addEventListener('paste', (ev) => {
                    try {
                        // allow default paste; but ensure value updated after paste to trigger direction auto
                        setTimeout(()=>{ try { ci.setAttribute('dir','auto'); } catch(e){} }, 10);
                    } catch(e){}
                });
            }
        } catch(e){}
    })();

    /* ---------- Replace any lingering "Start controversy" strings dynamically (defensive) ---------- */
    (function dynamicTextCleanup(){
        const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null, false);
        const bad1 = 'Start controversy';
        const bad2 = 'What do you have in mind?';
        const rep1 = 'Spill the teaâ€¦';
        const rep2 = 'No comments hereâ€¦ yet.';
        let n;
        while ((n = walker.nextNode())) {
            try {
                if (n.nodeValue && n.nodeValue.indexOf(bad1) !== -1) n.nodeValue = n.nodeValue.replace(bad1, rep1);
                if (n.nodeValue && n.nodeValue.indexOf(bad2) !== -1) n.nodeValue = n.nodeValue.replace(bad2, rep2);
            } catch(e){}
        }
    })();

    /* ---------- Small UX: show tiny toast when copying link or sharing fallback ---------- */
    (function smallToasts(){
        function show(msg, dur=2200){
            let t = document.getElementById('ggSmallToast');
            if (!t) {
                t = document.createElement('div');
                t.id = 'ggSmallToast';
                t.style.position = 'fixed';
                t.style.bottom = '120px';
                t.style.left = '50%';
                t.style.transform = 'translateX(-50%)';
                t.style.background = 'rgba(0,0,0,0.8)';
                t.style.color = '#fff';
                t.style.padding = '8px 14px';
                t.style.borderRadius = '14px';
                t.style.fontSize = '13px';
                t.style.zIndex = '20000';
                t.style.boxShadow = '0 6px 22px rgba(0,0,0,0.6)';
                document.body.appendChild(t);
            }
            t.textContent = msg;
            t.style.opacity = '1';
            t.style.display = 'block';
            setTimeout(()=>{ t.style.opacity = '0'; setTimeout(()=>{ t.style.display='none'; }, 300); }, dur);
        }
        // Expose for other parts
        window.ggShowToast = show;
    })();

})();
</script></body>
</html>